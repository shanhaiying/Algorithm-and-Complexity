### **Summations**

由于算法分析过程中，我们经常碰到算法中含有**while**语句和**for**语句，在分析这种语句复杂度时，找出循环中执行次数最多语句，计算其迭代次数是常用方法。这一过程转化为**数列或者级数求和问题**。

#### 1.等差、等比数列求和公式

+ 等差数列：给定等差数列$a_0,a_1,\dots,a_n$，公差为$d$，前$n$项和为：$$\sum_{i=0}^na_{i} = (n+1)a_0 + \frac{n(n+1)}{2}d$$
+ 等比数列：给定等比数列$a_0,a_1,\dots,a_n$，公比为$q$，前$n$项和为：$$ \sum_{i=0}^na_{i} = \left\{ \begin{array} &\frac{a_0(1-q^{n+1})}{1-q}& q \neq 1 \\ (n+1)a_0 & q = 1\end{array} \right. $$

#### 2.常见的级数求和

+ **Arithmetic series**: $$\sum_{k=1}^{n}k = 1 + 2 + \dots + n = \frac{n(n+1)}{2} = \Theta(n^2)$$
+ **sum of squares**: $$\sum_{k=0}^{n}k^{2} = \frac{n(n+1)(2n+1)}{6}=\Theta(n^3)$$
+ **sum of cubes**: $$\sum_{k=0}^{n}k^{3} = \frac{n^{2}(n+1)^{2}}{4}=\Theta(n^4)$$
+ **算术级数的前$n$项和，在$O$意义下比其末项高出$1$阶**
+ **Geometric series**: when $x \neq 1$, $$\sum_{k=0}^{n}x^{k} = 1 + x + x^{2} + \dots + x^{n} = \frac{x^{n+1} - 1}{x -1} $$
+ **几何级数的前$n$项和，在$O$意义下与其末项同阶**
+ **Geometric series**: $|x| < 1$, $$\sum_{k=0}^{\infty}x^{k} = \frac{1}{1-x} = O(1)$$
+ **Harmonic series**: $$\sum_{k=1}^{n}\frac{1}{k} = \ln n + O(1)$$
+ **logarithmic series**: $$\sum_{k=1}^{n}\log k = \Theta(n\log n)$$

#### 3.估计级数上下界的常用方法

+ **数学归纳法**: 运用数学归纳法估计级数上下界时，我们并不需要确切的知道级数的上下界，我们可以归纳假设给出一个大概的上下界，再进行证明。值得注意的是，当运用数学归纳法证明含有渐进记号的级数时，我们需要证明小心隐藏在渐进记号后面的“常数”是不是真的常数。

+ **缩放**: 对于级数，一个**较弱**的缩放是，当求其上界时，我们把级数里面的所有项都放大到最大项；当求其下界时，我们将所有项都缩小为最小项。除此之外，我们还可以借助**几何级数**的思想：如果$a_{k+1}/a_{k} \leq r,\forall k \geq 0$，而且$0 < r < 1$。那么我们就有$a_{k} \leq a_{0}r^{k}$，于是：$$\sum_{k=0}^{n}a_{k} \leq a_{0}\sum_{k=0}^{\infty}r^{k} = \frac{a_{0}}{1-r}$$。**运用这一方法要注意的是，这里的$r$必须是一个常数，而不能和$n$相关**。

+ **拆分**: 将不易求上下界的级数拆分为两个或者多个容易求上下界的级数，分别求解。拆分的方法有许多，主要可以分为：将原本级数求和的顺序打乱；对级数的各项重新分组；**如果级数的前面几项都是与$n$无关的，那么可以舍弃，只关注后面的项**。

+ **运用积分**:对于严格递增的函数$f(x)$ 有：$$\int_{m-1}^{n}f(x)\mathrm{d}x \leq \sum_{k=m}^{n}f(x) \leq \int_{m}^{n+1}f(x)\mathrm{d}x$$；对于严格递减的函数有：$$\int_{m-1}^{n}f(x)\mathrm{d}x \geq \sum_{k=m}^{n}f(x) \geq \int_{m}^{n+1}f(x)\mathrm{d}x$$

  



